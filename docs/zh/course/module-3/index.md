# 模組三：安裝高速電梯

:::tip 學習目標
**目標級分**：APCS 4 級分  
**預計學習時間**：4-6 週  
**前置要求**：完成模組一與模組二
:::

## 📖 模組介紹

為了快速抵達高樓層，普通樓梯已不敷使用。此階段將安裝「**高速電梯**」——也就是關鍵的**資料結構**與**核心演算法**。

本模組將引入一系列基礎但極其重要的**抽象資料型態（Abstract Data Types, ADT）**與**基石演算法**。它們如同摩天大樓中的高速電梯，能夠讓程式設計師繞過緩慢、暴力的「爬樓梯」方法，以更高的效率解決更大規模的問題。

掌握這些工具，是從「能夠解決問題」到「能夠**高效地**解決問題」的關鍵轉變。

## 🚀 質的飛躍

### 為什麼需要高速電梯？

在前兩個模組中，我們主要使用**暴力法（Brute Force）**：
- 遍歷所有可能性
- 簡單直觀，但效率不高
- 在資料量大時會遇到瓶頸

**4 級分的關鍵**在於能夠：
- 選擇正確的資料結構
- 設計高效的演算法
- 理解時間與空間的權衡

### 本模組將建立的能力

- ✅ **資料結構思維**：選擇適合問題的資料結構
- ✅ **遞迴思維**：將問題分解為相似的子問題
- ✅ **搜尋策略**：系統性地探索解空間
- ✅ **效率分析**：理解演算法的時間複雜度

## 📚 單元內容

### [C1: 順序與存取：堆疊 (LIFO) 與佇列 (FIFO)](/zh/course/module-3/c1-stack-queue)

**核心概念**：
- 堆疊（Stack）：後進先出（LIFO）
- 佇列（Queue）：先進先出（FIFO）
- Python 實作：list vs `collections.deque`
- 抽象資料型態的概念

**為什麼這很重要？**  
堆疊和佇列是兩種最基礎的線性資料結構，它們的核心區別在於**元素的存取順序**。理解並能高效地實現它們，是學習後續更複雜演算法（如圖形遍歷）的前提。

**APCS 應用**：
- 括弧配對檢查
- 表達式求值
- 廣度優先搜尋（BFS）的基礎

**推薦習題**：c471 (物品堆疊)、P-3-2 (括弧配對)

**關鍵警告**：
:::danger 效能陷阱
永遠不要用 `list.pop(0)` 實作佇列！  
必須使用 `collections.deque`，這是 APCS 的標準作法。
:::

---

### [C2: 探索解空間：遞迴、枚舉與回溯](/zh/course/module-3/c2-recursion)

**核心概念**：
- 遞迴（Recursion）的信念飛躍
- 枚舉（Enumeration）：系統性列舉所有可能
- 回溯（Backtracking）：帶剪枝的深度優先搜尋
- 通用回溯模板

**為什麼這很重要？**  
當問題的解無法透過簡單的公式直接計算，而需要系統性地**嘗試所有可能性**時，遞迴、枚舉與回溯就成為了核心的解決策略。

**APCS 應用**：
- 全排列生成
- N-皇后問題
- 子集合生成
- 路徑搜尋

**推薦習題**：全排列生成、N-皇后問題

**關鍵概念**：
:::tip 遞迴的精髓
1. **基礎情況（Base Case）**：遞迴的終止條件
2. **遞迴步驟（Recursive Step）**：將問題分解為更小的同類問題
3. **信念飛躍**：相信函式對於更小的問題能正確求解
:::

---

### [C3: 效率的必要性：排序與二分搜尋](/zh/course/module-3/c3-sorting)

**核心概念**：
- 排序演算法：Timsort（Python 內建）
- 二分搜尋（Binary Search）：O(log N) 搜尋
- 答案空間上的二分搜尋
- 分治法（Divide and Conquer）初探

**為什麼這很重要？**  
在處理大量資料時，**效率就是一切**。排序和二分搜尋是演算法領域中提高效率的兩大基石。一個有序的序列能夠支持更快的搜尋、合併等操作。

**APCS 應用**：
- 在已排序序列中查找元素
- 找到滿足條件的最小/最大值
- 優化搜尋範圍

**推薦習題**：互補團隊、圓環出口

**效率對比**：
| 搜尋方法 | 時間複雜度 | 適用情況 |
|---------|-----------|---------|
| 線性搜尋 | O(N) | 未排序序列 |
| 二分搜尋 | O(log N) | 已排序序列 |

對於 N = 1,000,000：
- 線性搜尋：最多 1,000,000 次比較
- 二分搜尋：最多 20 次比較 ⚡

---

## 🎯 學習建議

### 學習順序
1. **C1 → C2 → C3**：按照順序學習
2. C1 和 C3 相對獨立，但 C2 的遞迴思維會貫穿後續所有內容
3. 建議在 C2 投入較多時間，徹底理解遞迴

### 時間分配
- **C1 堆疊與佇列**：1 週（概念簡單但重要）
- **C2 遞迴與回溯**：2-3 週（需要時間消化與練習）
- **C3 排序與搜尋**：1-2 週

### 學習重點

:::tip 重點提示
1. **C1 的資料結構選擇**：記住何時用 list，何時用 deque
2. **C2 的遞迴思維**：這是最難但最重要的，掌握回溯模板
3. **C3 的二分搜尋**：不只是在陣列中搜尋，更要理解「答案空間」的概念
:::

## 🆚 模組二 vs 模組三

| 面向 | 模組二（核心結構） | 模組三（高速電梯） |
|------|------------------|-------------------|
| **核心主題** | 資料處理 | 資料結構與演算法 |
| **思維方式** | 模組化 | 抽象化 |
| **解題策略** | 預處理優化 | 選擇正確的工具 |
| **APCS 級分** | 3 級分 | 4 級分 |
| **關鍵能力** | 處理複雜資料 | 高效解決問題 |

## 📊 完成檢查表

在進入模組四之前，請確認你已經：

### 知識掌握
- [ ] 能夠正確實作堆疊與佇列
- [ ] 理解遞迴的原理與應用
- [ ] 能夠使用回溯法解決枚舉問題
- [ ] 能夠正確實作二分搜尋

### 實戰能力
- [ ] 完成所有推薦習題
- [ ] 能在 5 分鐘內寫出二分搜尋程式碼
- [ ] 能使用回溯模板解決排列組合問題
- [ ] 知道何時使用 deque 而非 list

### 效能意識
- [ ] 理解 O(log N) 的威力
- [ ] 能識別問題是否適合用二分搜尋
- [ ] 理解遞迴的時間與空間成本
- [ ] 能避免使用 `list.pop(0)`

:::info 準備好了嗎？
如果以上檢查表都完成了，恭喜你！你已經安裝好高速電梯，可以進入[模組四：封頂豪華頂層](/zh/course/module-4/)，挑戰最高階的演算法了。
:::

## 💡 學習心得分享

### 常見困難與解決方法

**困難 1：遞迴難以理解**
- 解決：從最簡單的例子開始（如階乘、費波那契數列）
- 在紙上畫出遞迴樹，追蹤每次呼叫
- 相信「信念飛躍」，不要試圖追蹤所有細節

**困難 2：回溯法的模板難以應用**
- 解決：先理解模板的每個部分的作用
- 從經典問題開始（全排列、N-皇后）
- 多做幾題，培養識別模式的能力

**困難 3：二分搜尋的邊界條件總是出錯**
- 解決：使用固定的模板，不要每次都重新思考
- 記住：`left <= right`，`right = mid - 1`
- 用小範例手動追蹤，確認邊界處理正確

**困難 4：不知道何時該用哪種資料結構**
- 解決：記住決策樹
  - 需要 LIFO（後進先出）→ 堆疊
  - 需要 FIFO（先進先出）→ 佇列
  - 需要查找「是否存在」→ set
  - 需要按鍵查找值 → dict

## 🎓 給老師與家長

### 教學建議

1. **C1 堆疊與佇列**：用生活例子（盤子堆疊、排隊）幫助理解
2. **C2 遞迴**：這是最難的部分，需要大量練習
3. **C3 二分搜尋**：用視覺化工具展示搜尋範圍如何縮小

### 評量方式

- C1：給定問題，檢查能否選擇正確的資料結構
- C2：給定枚舉問題，檢查能否使用回溯法
- C3：給定搜尋問題，檢查能否正確實作二分搜尋

---

## 🚀 開始學習

<div class="action-buttons">

[開始 C1：堆疊與佇列](/zh/course/module-3/c1-stack-queue)

[回到課程總覽](/zh/course/)

</div>

<style>
.action-buttons {
  display: flex;
  gap: 1rem;
  margin: 2rem 0;
  flex-wrap: wrap;
}

.action-buttons a {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background-color: var(--vp-c-brand-1);
  color: white;
  text-decoration: none;
  border-radius: 6px;
  font-weight: 500;
  transition: all 0.2s;
}

.action-buttons a:hover {
  background-color: var(--vp-c-brand-2);
  transform: translateY(-2px);
}

.action-buttons a:nth-child(2) {
  background-color: var(--vp-c-bg-soft);
  color: var(--vp-c-brand-1);
  border: 1px solid var(--vp-c-brand-1);
}

.action-buttons a:nth-child(2):hover {
  background-color: var(--vp-c-brand-soft);
}

table {
  width: 100%;
  margin: 1.5rem 0;
}
</style>
